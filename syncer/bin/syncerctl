#!/usr/bin/env python3

import datetime
import os
import json
import sys
import argparse
import productstatus.api
import productstatus.exceptions
import configparser
import lxml.etree
import syncer.config
import syncer.exceptions
import syncer.persistence
import syncer.wdb2ts
from _datetime import tzinfo

def _get_api(args):
    base_url = args.config.get('productstatus', 'url')
    verify_ssl = bool(int(args.config.get('productstatus', 'verify_ssl')))
    return productstatus.api.Api(base_url, verify_ssl=verify_ssl)

def create_status_information(reference_time=None, updated=None, id=None):
    return {'reference_time': reference_time,
            'updated': updated,
            'id': id}
    
        
def get_status_information_available(section):
    try:
        api = _get_api(args)
        product_identifier = section['product']
        product = api.product[product_identifier]
        productinstances = api.productinstance.objects
        productinstances.filter(product=product)
        productinstances.order_by('-reference_time')
        productinstances.limit(1)
        productinstance = productinstances[0]
        return create_status_information(productinstance.reference_time, productinstance.created, productinstance.id)
    except productstatus.exceptions.ResourceNotFoundException:
        return create_status_information()

def get_status_information_wdb(host, user, model):
        wdb_access = syncer.wdb.WDB(host, user)
        status = wdb_access.get_status(model)
        if status:
            return create_status_information(status[0], status[1])
        else:
            return create_status_information()
        
def get_status_information_wdb2ts(base_url, services, section):
    try:
        wdb2ts_access = syncer.wdb2ts.WDB2TS(base_url, services)
        for info in wdb2ts_access.get_load_status().values():
            if section['data_provider'] in info:
                status_information = info[section['data_provider']]
                if status_information:
                    return create_status_information(status_information['referencetime'], status_information['updated'])
    except syncer.exceptions.WDB2TSServiceClientErrorException:
        pass
    return create_status_information()
        
def get_status_information_for_model(args, model):
    subsection = 'model_' + model

    return {'model': {'data_provider': args.config.get(subsection, 'data_provider'),
                      'age_warning': args.config.get(subsection, 'model_run_age_warning'),
                      'age_critical': args.config.get(subsection, 'model_run_age_critical')},
            'available': get_status_information_available(args.config[subsection]),
            'wdb': get_status_information_wdb(args.config.get('wdb', 'host'), args.config.get('wdb', 'user'), args.config.get(subsection, 'data_provider')),
            'wdb2ts': get_status_information_wdb2ts(args.config.get('wdb2ts', 'base_url'), args.config.get('wdb2ts', 'services').split(','), args.config[subsection])}
    
def get_status_information(args):
    models = [m.strip() for m in args.config.get('syncer', 'models').split(',')]
    if hasattr(args, 'model') and args.model:
        models= [m for m in models if m in args.model]
    ret = {}
    for model in models:
        ret[model] = get_status_information_for_model(args, model)
    return ret

def _serialize(what):
    if isinstance(what, datetime.datetime):
        t = what.astimezone(datetime.timezone.utc)
        return t.strftime('%Y-%m-%dT%H:%M:%SZ')

def _deserialize_datetime(input):
    ret = datetime.datetime.strptime(input, '%Y-%m-%dT%H:%M:%SZ')
    ret = ret.replace(tzinfo=datetime.timezone.utc)
    return ret

def exec_check(args):
    status_information = get_status_information(args)
    sys.stderr.write("# data_provider; model_run_age_warning; model_run_age_critical; model_run_id; available_reference_time; available_updated; wdb_run_id; wdb_reference_time; wdb_updated; wdb2ts_run_id; wdb2ts_reference_time; wdb2ts_updated\n")
    sys.stderr.write("# missing values denoted with a dash, lines beginning with a hash are comments\n")
    
    for si in status_information.values():
        print(si['model']['data_provider'] or '-',
              si['model']['age_warning'] or '-',
              si['model']['age_critical'] or '-',
              si['available']['id'] or '-',
              _serialize(si['available']['reference_time']) or '-',
              _serialize(si['available']['updated']) or '-',
              si['wdb']['id'] or '-',
              _serialize(si['wdb']['reference_time']) or '-',
              _serialize(si['wdb']['updated']) or '-',
              si['wdb2ts']['id'] or '-',
              _serialize(si['wdb2ts']['reference_time']) or '-',
              _serialize(si['wdb2ts']['updated']) or '-',
              sep=';')

def exec_status(args):
    status_information = get_status_information(args)
    print(json.dumps(status_information, sort_keys=True, indent=4, separators=(',', ': '), default=_serialize))

def exec_load(args):
    try:
        api = _get_api(args)
        pi = api.productinstance[args.product_instance_id]
        print('%s = %s' % (args.product_instance_id, pi))
        database = args.config.get('syncer', 'state_database_file')
        state_database = syncer.persistence.StateDatabase(database, create_if_missing=False)
        state_database.add_productinstance_to_be_processed(pi, args.force)
        print('Queued for processing')
        return syncer.config.EXIT_SUCCESS
    except syncer.exceptions.MissingStateFile:
        print('Unable to find state file')
        return syncer.config.EXIT_CONFIG
    except productstatus.exceptions.ProductstatusException as e:
        print('Error when contacting productstatus service:', str(e))
        return syncer.config.EXIT_CONNECT_PRODUCTSTATUS
    


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    sub = parser.add_subparsers(help='Try `syncerctl <sub-command> --help`')

    # parser for the 'check' command
    check = sub.add_parser('check', help='Print machine-readable model run status information')
    check.add_argument('--model', action='append', help='Show information only from this model. Can be specified multiple times.')
    check.set_defaults(func=exec_check)

    # parser for the 'check' command
    status = sub.add_parser('status', help='Print model run status information')
    status.add_argument('--model', action='append', help='Show information only from this model. Can be specified multiple times.')
    status.set_defaults(func=exec_status)

    # parser for the 'load' command
    load = sub.add_parser('load', help='Ask Syncer to load and activate a specific product instance')
    load.add_argument('product_instance_id', type=str, help='Product instance id from Productstatus REST API service')
    load.add_argument('--force', action='store_true', help='Ignore sanity checks')
    load.set_defaults(func=exec_load)
    
    # common options for status checks
    for class_ in (check, status, load):
        class_.add_argument('-c', '--config', type=str, help='Read productstatus config from the given file', default=syncer.config.DEFAULT_CONFIG_PATH)

    
    args = parser.parse_args()

    if not os.path.exists(args.config):
        print('Unable to find config file')
        sys.exit(syncer.config.EXIT_CONFIG)
    config_parser = configparser.SafeConfigParser()
    config_parser.read(args.config)
    args.config = config_parser
    
    sys.exit(args.func(args))
