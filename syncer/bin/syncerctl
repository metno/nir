#!/usr/bin/env python3

import os
import json
import sys
import argparse
import urllib.request
import urllib.error
import productstatus.api
import productstatus.exceptions
import configparser
import syncer.config
import syncer.exceptions
import syncer.persistence
from datetime import tzinfo, datetime, timezone


def _get_api(args):
    base_url = args.config.get('productstatus', 'url')
    verify_ssl = bool(int(args.config.get('productstatus', 'verify_ssl')))
    return productstatus.api.Api(base_url, verify_ssl=verify_ssl)

def create_status_information(reference_time=None, updated=None, id=None):
    return {'reference_time': reference_time,
            'updated': updated,
            'id': id}

def _get_status_information_from_db(state_database, model, type):
    incoming = state_database.get_last_incoming(model, type)
    if incoming:
        return create_status_information(incoming[1], incoming[2], incoming[0])
    else:
        return create_status_information()

def get_status_information_available(state_database, model):
    return _get_status_information_from_db(state_database, model, syncer.persistence.StateDatabase.DATA_AVAILABLE)

def get_status_information_wdb(state_database, model):
    return _get_status_information_from_db(state_database, model, syncer.persistence.StateDatabase.DATA_WDB_OK)
         
def get_status_information_wdb2ts(state_database, model):
    return _get_status_information_from_db(state_database, model, syncer.persistence.StateDatabase.DATA_WDB2TS_OK)

def get_status_information_config(args, model):
    subsection = 'model_' + model
    return {'data_provider': args.config.get(subsection, 'data_provider'),
            'age_warning': args.config.get(subsection, 'model_run_age_warning'),
            'age_critical': args.config.get(subsection, 'model_run_age_critical')}

def get_status_information_for_model(args, model):
    database = args.config.get('syncer', 'state_database_file')
    state_database = syncer.persistence.StateDatabase(database, create_if_missing=False)
    return {'model': get_status_information_config(args, model),
            'available': get_status_information_available(state_database, model),
            'wdb': get_status_information_wdb(state_database, model),
            'wdb2ts': get_status_information_wdb2ts(state_database, model)}
    
def get_status_information(args):
    models = [m.strip() for m in args.config.get('syncer', 'models').split(',')]
    if hasattr(args, 'model') and args.model:
        models= [m for m in models if m in args.model]
    ret = {}
    for model in models:
        ret[model] = get_status_information_for_model(args, model)
    return ret

def _serialize(what):
    if isinstance(what, datetime):
        if what.tzinfo:
            t = what.astimezone(timezone.utc)
        else:
            t = what
        return t.strftime('%Y-%m-%dT%H:%M:%SZ')

def exec_check(args):
    status_information = get_status_information(args)
    sys.stderr.write("# data_provider; model_run_age_warning; model_run_age_critical; model_run_id; available_reference_time; available_updated; wdb_run_id; wdb_reference_time; wdb_updated; wdb2ts_run_id; wdb2ts_reference_time; wdb2ts_updated\n")
    sys.stderr.write("# missing values denoted with a dash, lines beginning with a hash are comments\n")
    for si in status_information.values():
        print(si['model']['data_provider'] or '-',
              si['model']['age_warning'] or '-',
              si['model']['age_critical'] or '-',
              si['available']['id'] or '-',
              _serialize(si['available']['reference_time']) or '-',
              _serialize(si['available']['updated']) or '-',
              si['wdb']['id'] or '-',
              _serialize(si['wdb']['reference_time']) or '-',
              _serialize(si['wdb']['updated']) or '-',
              si['wdb2ts']['id'] or '-',
              _serialize(si['wdb2ts']['reference_time']) or '-',
              _serialize(si['wdb2ts']['updated']) or '-',
              sep=';')

def exec_status(args):
    status_information = get_status_information(args)
    print(json.dumps(status_information, sort_keys=True, indent=4, separators=(',', ': '), default=_serialize))

def exec_load(args):
    try:
        api = _get_api(args)
        pi = api.productinstance[args.product_instance_id]
        print('%s = %s' % (args.product_instance_id, pi))
        if args.product_instance_id != pi.id:
            raise productstatus.exceptions.ProductstatusException('Invalid product instance id: ' + args.product_instance_id)
        database = args.config.get('syncer', 'state_database_file')
        state_database = syncer.persistence.StateDatabase(database, create_if_missing=False)
        state_database.add_productinstance_to_be_processed(pi, force=args.force, even_if_previously_loaded=True)
        print('Queued for processing')
        return syncer.config.EXIT_SUCCESS
    except syncer.exceptions.MissingStateFile:
        print('Unable to find state file')
        return syncer.config.EXIT_CONFIG
    except productstatus.exceptions.ProductstatusException as e:
        print('Error when contacting productstatus service:', str(e))
        return syncer.config.EXIT_CONNECT_PRODUCTSTATUS
    
def exec_update(args):
    base_url = args.config.get('wdb2ts', 'base_url')
    for s in [service.strip() for service in args.config.get('wdb2ts', 'services').split(',')]:
        
        atomized_service = s.split('/', 1)
        s = atomized_service[0]
        if len(atomized_service) > 1:
            api_version = '/' + atomized_service[1]
        else:
            api_version = ''
        
        full_url = '%s/%supdate%s' % (base_url, s, api_version)
        try:
            status = urllib.request.urlopen(full_url)
            if status.getcode() != '200':
                print(s + ':\t updated')
            else:
                print(s + ':\tERROR: ' + str(status.read()))
        except urllib.error.HTTPError as e:
            print(s + ' \t(' + full_url + '): ' + str(e))
    return syncer.config.EXIT_SUCCESS


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    sub = parser.add_subparsers(help='Try `syncerctl <sub-command> --help`')

    # parser for the 'check' command
    check = sub.add_parser('check', help='Print machine-readable model run status information')
    check.add_argument('--model', action='append', help='Show information only from this model. Can be specified multiple times.')
    check.set_defaults(func=exec_check)

    # parser for the 'check' command
    status = sub.add_parser('status', help='Print model run status information')
    status.add_argument('--model', action='append', help='Show information only from this model. Can be specified multiple times.')
    status.set_defaults(func=exec_status)

    # parser for the 'load' command
    load = sub.add_parser('load', help='Ask Syncer to load and activate a specific product instance')
    load.add_argument('product_instance_id', type=str, help='Product instance id from Productstatus REST API service')
    load.add_argument('--force', action='store_true', help='Ignore sanity checks')
    load.set_defaults(func=exec_load)
    
    update = sub.add_parser('update', help = 'Send update requests to wdb2ts.')
    update.set_defaults(func=exec_update)
    
    # common options for status checks
    for class_ in (check, status, load, update):
        class_.add_argument('-c', '--config', type=str, help='Read productstatus config from the given file', default=syncer.config.DEFAULT_CONFIG_PATH)

    
    args = parser.parse_args()

    if not os.path.exists(args.config):
        print('Unable to find config file')
        sys.exit(syncer.config.EXIT_CONFIG)
    config_parser = configparser.SafeConfigParser()
    config_parser.read(args.config)
    args.config = config_parser
    
    sys.exit(args.func(args))
